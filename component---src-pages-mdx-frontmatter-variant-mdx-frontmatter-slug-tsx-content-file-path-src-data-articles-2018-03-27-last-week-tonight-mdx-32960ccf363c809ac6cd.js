"use strict";(self.webpackChunklucas_pluvinage=self.webpackChunklucas_pluvinage||[]).push([[191],{8453:function(e,l,t){t.r(l),t.d(l,{Head:function(){return h},default:function(){return d}});var n=t(7294),a=t(1151);function r(e){const l=Object.assign({p:"p",h2:"h2",h3:"h3",code:"code",ul:"ul",li:"li",em:"em",a:"a"},(0,a.ah)(),e.components);return n.createElement(n.Fragment,null,n.createElement(l.p,null,"Back to Cambridge, I decided to focus on assembly code generation, which is the last layer of compilation.\nThere are multiple things to perform to create a new target backend."),"\n",n.createElement(l.h2,null,"TODO"),"\n",n.createElement(l.h3,null,"In ",n.createElement(l.code,null,"/asmcomp/"),":"),"\n",n.createElement(l.p,null,"This directory contains for each architecture a sub-directory that implements architecture-specific code. I created my own ",n.createElement(l.code,null,"xtensa")," sub-directory, which contains the following files:"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"emit.mlp"),": a pre-processed OCaml file (on which syntax highlighting has a lot of troubles by the way). It implements ",n.createElement(l.code,null,"asmcomp/emit.mli")," and consists in translating a ",n.createElement(l.code,null,"Linearize.fundecl")," code to assembly. This is obviously architecture-specific and I worked on it by roughly translating what was done on ARM."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"arch.ml"),": defines architecture-dependant values such as endianness, addressing modes."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"proc.ml"),": describes registers, calling conventions and the side effects of instructions on registers. Used by the register allocator."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"selection.ml"),": operation and addressing selection overriding default behavior. Useful as Xtensa doesn't have double precision hardware floating point for example."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"scheduling.ml"),": instruction timing hints."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"CSE.ml"),": common subexpression elimination. Set to default."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"reload.ml"),": instruction reloading. Set to default."),"\n"),"\n",n.createElement(l.h3,null,"In ",n.createElement(l.code,null,"/asmrun/"),":"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"xtensa.S"),": an architecture-specific, handwritten assembly code is here to make the glue between C and OCaml code. It handles calls to the garbage collector."),"\n"),"\n",n.createElement(l.h2,null,"Progress"),"\n",n.createElement(l.h3,null,"Writing code"),"\n",n.createElement(l.p,null,"Last week I finished to fill ",n.createElement(l.code,null,"emit.mlp")," and ",n.createElement(l.code,null,"proc.ml")," to start debugging. I figured out when linking failed that I forgot to fill ",n.createElement(l.code,null,"xtensa.S")," assembly stubs.\nThere are a bit of features to fill in:"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_call_gc"),": call the runtime garbage collector."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_alloc1"),": allocate 4 bytes"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_alloc2"),": allocate 8 bytes"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_allocN"),": allocate N-4 bytes, with N given in a register"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_c_call"),": call a C function"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_start_program"),": entry point after caml runtime startup"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_callback_exn"),": callback from C to OCaml with one argument"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_callback2_exn"),": callback from C to OCaml with two arguments"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_callback3_exn"),": callback from C to OCaml with three arguments"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"trap_handler"),": callback from exception"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_raise_exn"),": raise an exception from OCaml"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"caml_raise_exception"),": raise an exception from C"),"\n"),"\n",n.createElement(l.h3,null,"Linking it"),"\n",n.createElement(l.p,null,"The process is not that straightforward as compiling and linking for ESP32 relies on the espressif's Iot Development Framework with contains the linker script and required libraries. The ~easiest~ way I found, ",n.createElement(l.em,null,"yet"),", to have some OCaml native code running on the ESP32 is the following:"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"ocamlopt-esp32 test.ml -dstartup -o main.o -S -dstartup")," will generate two assembly files and fail on linking:"),"\n"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"main.s")," is the main source code"),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"main.o.startup.s")," is the startup code which will then call ",n.createElement(l.code,null,"main.s")," entry point."),"\n"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,"Create ",n.createElement(l.code,null,"startup-c.c")," that will be the glue between ESP-IDF entry point ",n.createElement(l.code,null,"app_main")," and OCaml runtime entry point ",n.createElement(l.code,null,"caml_main"),"."),"\n",n.createElement(l.li,null,"Put all these files in an ESP-IDF component subdirectory of a ",n.createElement(l.a,{href:"https://github.com/espressif/esp-idf/tree/2935e95/examples/get-started/hello_world"},"project"),". That is for example ",n.createElement(l.code,null,"hello_caml/main/"),"."),"\n",n.createElement(l.li,null,"Put library files generated by the compilation of ocaml-esp32 in a lib directory ",n.createElement(l.code,null,"hello_caml/lib/"),":"),"\n"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,n.createElement(l.code,null,"libasmrun.a")),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"libstdlib.a")),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"std_exit.o")),"\n"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,"Create a relocatable object file ",n.createElement(l.code,null,"startup-c.o")," from ",n.createElement(l.code,null,"startup-c.c"),", ",n.createElement(l.code,null,"main.s")," and ",n.createElement(l.code,null,"main.o.startup.s"),"."),"\n",n.createElement(l.li,null,"Add the libraries in the component Makefile through ",n.createElement(l.code,null,"COMPONENT_ADD_LDFLAGS")," and ",n.createElement(l.code,null,"COMPONENT_EXTRA_INCLUDES"),"."),"\n",n.createElement(l.li,null,n.createElement(l.code,null,"make")),"\n"),"\n",n.createElement(l.h3,null,"Debugging stuff"),"\n",n.createElement(l.ul,null,"\n",n.createElement(l.li,null,"I use QEMU for debugging. This ",n.createElement(l.a,{href:"https://github.com/Ebiroll/qemu_esp32"},"github")," explains how to do it. It works out of the box with the gdb shipped with the repository."),"\n",n.createElement(l.li,null,"ESP32 WROVER kits have a JTAG interface, that will allow me to test my code on real hardware, once it works on QEMU."),"\n"),"\n",n.createElement(l.h2,null,"Funny stuff encountered"),"\n",n.createElement(l.h3,null,"Conditional branches don't have legs"),"\n",n.createElement(l.p,null,"The conditional branch has a range of +-128 bytes. My generated code tried to jump further, generating the ",n.createElement(l.code,null,"Error: jump target out of range; no usable trampoline found"),". I had to put a jump instruction close the conditional as I often need to go far away. The jump to label has a range of +-131075 bytes. If that's not enough I can address the whole space with a jump to address in register."),"\n",n.createElement(l.h3,null,"Never look forward"),"\n",n.createElement(l.p,null,"The PC-relative load has a range of [-262141, -4]. Therefore data must be before every load and store instructions. The assembler handles this alone when compiling a single file. But the linker doesn't seem to handle that well accross files. I had to put additional symbols."),"\n",n.createElement(l.h3,null,"What you see is not what you get"),"\n",n.createElement(l.p,null,'Xtensa processors can have a feature called "Windowed registers". It allows a processor to have a given number of registers (64) but only a subset interval of these registers are visible at each instant (16).'),"\n",n.createElement(l.p,null,"On call, you can ask the processor to move this window to the right, by a number of registers. It can be 0, 4, 8, or 12. There are special instructions that magically handles the fact that this window can overflow by spilling registers in stack memory.\nThat makes the ABI a bit special as ",n.createElement(l.code,null,"a8")," register of the caller is the ",n.createElement(l.code,null,"a0")," register of the callee if the ",n.createElement(l.code,null,"call8")," instruction is used."),"\n",n.createElement(l.p,null,"Using ",n.createElement(l.code,null,"call4"),", ",n.createElement(l.code,null,"call8")," and ",n.createElement(l.code,null,"call12")," is compatible as the ",n.createElement(l.code,null,"entry")," function handles everything for you. However ",n.createElement(l.code,null,"call0")," is not compatible with ",n.createElement(l.code,null,"entry")," as the document explains it throws an IllegalInstruction exception. Guess what? I wanted to start with ",n.createElement(l.code,null,"call0")," ABI as it's simpler to reason about, but C code is compiled against ",n.createElement(l.code,null,"call8")," ABI."))}var c=function(e){void 0===e&&(e={});const{wrapper:l}=Object.assign({},(0,a.ah)(),e.components);return l?n.createElement(l,e,n.createElement(r,e)):r(e)},o=t(8733),i=t(4781),s=t(7166),u=t(4321);const m=e=>{var l,t,n,a,r,c,u,m;const d=null===(l=e.data.mdx)||void 0===l||null===(t=l.frontmatter)||void 0===t?void 0:t.tags,h=null!==(n=null==d?void 0:d.length)&&void 0!==n&&n&&null!==(a=s.tagsColor[d[0]])&&void 0!==a?a:s.tagsColor.default;return(0,o.tZ)(i.A,{page:null===(r=e.data.mdx)||void 0===r||null===(c=r.frontmatter)||void 0===c?void 0:c.variant,article:null===(u=e.data.mdx)||void 0===u||null===(m=u.frontmatter)||void 0===m?void 0:m.title},(0,o.tZ)("div",{sx:{padding:[1,3]}},(0,o.tZ)("div",{sx:{borderLeft:"solid "+h+" 8px",paddingX:[2,4]}},e.children)))};function d(e){return n.createElement(m,e,n.createElement(c,e))}const h=e=>{var l,t,n;return(0,o.tZ)(u.x,{title:null!==(l=null===(t=e.data.mdx)||void 0===t||null===(n=t.frontmatter)||void 0===n?void 0:n.title)&&void 0!==l?l:void 0})}}}]);
//# sourceMappingURL=component---src-pages-mdx-frontmatter-variant-mdx-frontmatter-slug-tsx-content-file-path-src-data-articles-2018-03-27-last-week-tonight-mdx-32960ccf363c809ac6cd.js.map