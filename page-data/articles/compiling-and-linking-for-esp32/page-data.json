{"componentChunkName":"component---src-pages-mdx-frontmatter-variant-mdx-frontmatter-slug-tsx-content-file-path-src-data-articles-2018-04-27-compiling-and-linking-for-esp-32-mdx","path":"/articles/compiling-and-linking-for-esp32/","result":{"data":{"mdx":{"frontmatter":{"title":"Compiling and linking for ESP32","description":"A guide to a full native compilation workflow for ESP32","date":"2018-04-27 10:13:37 +0000","tags":null,"inline":null,"slug":"compiling-and-linking-for-esp32","hero_image_alt":null,"variant":"articles","hero_image":null},"body":"I've got native OCaml code running! It seems to pass all the runtime tests, and as I fixed some GC segfaults I'm now pretty confident in the backend code. \nIt's not optimized at all, but you can now experiment with OCaml on ESP32 MCUs. \n\n## OCaml cross-compiler installation\n\nSwitch opam to OCaml version 4.06 or a 4.07 as only these two versions are supported, using the `opam switch` command.\n\nAdd my cross-compilation repository in opam, with:\n```\nopam repo add cross-esp32 https://github.com/TheLortex/opam-cross-esp32.git\n```\nAfter that, you'll be able to install the cross-compiler, with:\n```\nopam install ocaml-esp32\n```\n\nYou now have an OCaml cross-compiler for esp32 installed in `~/.opam/<switch>/esp32-sysroot/`. \n\n## Cross-compiling OCaml libraries\n\nYour favorite build system can already cross-compile code. You can either use\n* `jbuilder build -x esp32 ...`\n* `ocamlfind -toolchain esp32 ...`\n* `env OCAMLFIND_TOOLCHAIN=esp32 ocamlbuild ...`\nto build libraries.\n\nThe libraries used by these build systems are located in `~/.opam/<switch>/esp32-sysroot/lib/`. A good thing to know is that jbuilder automatically makes the difference between host code and target code, hence enabling the use of ppx tools. \n\n## Building an ESP32 application\n\nTo build an esp32 application, you'll need to link native code with the ESP-Iot Development Framework which contains libraries, bootloader code and linker scripts. \n\n[Hello caml](https://github.com/TheLortex/hello_caml) is an example of project structure using jbuilder that builds a flashable binary for esp32. \n\nBasically, it's not complicated:\n* Build and ship OCaml code into a single object:\n  - using the `-output-complete-obj` option on the native compiler `ocamlopt`.\n  - using `jbuilder build -x esp32 _build/default.esp32/main.exe.o` that will automatically use the option.\n* This object file's entry point is `caml_main`. So the next thing to do is create a `startup-c.c` file that defines a function `app_main` which calls `caml_main`. \n* Then everything needs to be linked together, and the ESP32 framework takes the lead to create the final binary. \n"}},"pageContext":{"id":"05dca384-226b-51e8-be49-be66facf7d7e","frontmatter__variant":"articles","frontmatter__slug":"compiling-and-linking-for-esp32","__params":{"frontmatter__variant":"articles","frontmatter__slug":"compiling-and-linking-for-esp32"},"frontmatter":{"title":"Compiling and linking for ESP32","slug":"compiling-and-linking-for-esp32","date":"2018-04-27 10:13:37 +0000","category":"esp32","description":"A guide to a full native compilation workflow for ESP32","variant":"articles"}}},"staticQueryHashes":["2744905544"],"slicesMap":{}}