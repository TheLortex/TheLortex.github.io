<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="//home/lucas/TheLortex.github.io/esp32/feed.xml" rel="self" type="application/atom+xml" /><link href="//home/lucas/TheLortex.github.io/esp32/" rel="alternate" type="text/html" /><updated>2018-03-20T18:34:54+00:00</updated><id>//home/lucas/TheLortex.github.io/esp32/</id><title type="html">MirageOS on ESP32 - a tale of cross-compilation</title><subtitle>In this blog I will explain and track my progress on Mirage, OCaml and ESP32 development. </subtitle><author><name>Lucas Pluvinage</name></author><entry><title type="html">Work in progress status and links</title><link href="//home/lucas/TheLortex.github.io/esp32/status/2018/03/20/status.html" rel="alternate" type="text/html" title="Work in progress status and links" /><published>2018-03-20T17:25:53+00:00</published><updated>2018-03-20T17:25:53+00:00</updated><id>//home/lucas/TheLortex.github.io/esp32/status/2018/03/20/status</id><content type="html" xml:base="//home/lucas/TheLortex.github.io/esp32/status/2018/03/20/status.html">&lt;h2 id=&quot;native-backend&quot;&gt;Native backend&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;OCaml 4.06.0 with xtensa target and custom settings to build the bytecode runtime on the ESP32. A lot of things are fairly hardcoded, so it’s not practical. The whole toolchain can’t be built right now, as it tries to built target binaries. The best way to have a functional cross-esp32 toolchain is to install the opam package from opam-cross-esp32.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/TheLortex/ocaml-esp32&quot;&gt;Github - ocaml-esp32&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;It can generate assembly but it can’t be linked classically as it needs to be linked with ESP-IDF tool. We might want a workaround.&lt;/li&gt;
  &lt;li&gt;I need to find a way to debug generated programs.&lt;/li&gt;
  &lt;li&gt;Current error on build is: &lt;code class=&quot;highlighter-rouge&quot;&gt;Error: jump target out of range; no usable trampoline found&lt;/code&gt;. It will be easily fixed but I don’t know if I should go with  &lt;a href=&quot;https://www.amazon.com/gp/product/B000JC2ZHA/&quot;&gt;this&lt;/a&gt; or &lt;a href=&quot;https://www.amazon.co.uk/gp/product/B074M8W4JY/&quot;&gt;this&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;cross-compilation-of-a-mirage-unikernel&quot;&gt;Cross-compilation of a Mirage unikernel&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Custom esp32 target in Mirage tool.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/TheLortex/mirage&quot;&gt;Github - mirage&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;OS bindings.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/TheLortex/mirage-esp32&quot;&gt;Github - mirage-esp32&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;opam-cross-esp32 working on the same scheme as opam-cross-android. It can be used to have a slightly functional OCaml cross-compiler to esp32 compatible with &lt;code class=&quot;highlighter-rouge&quot;&gt;ocamlfind -toolchain esp32&lt;/code&gt; command. However don’t expect to build unikernels with it &lt;em&gt;yet&lt;/em&gt;. Now figuring out which libraries are strictly necessary, which one should be build with host tools, which one are jbuilder and which one are causing troubles.
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/TheLortex/opam-cross-esp32&quot;&gt;Github - opam-cross-esp32&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;documentation&quot;&gt;Documentation&lt;/h2&gt;

&lt;p&gt;I need to work on documenting everything I wrote before it becomes too much of a mess.&lt;/p&gt;</content><author><name>Lucas Pluvinage</name></author><summary type="html">This article holds my Github projects links related to Mirage-OCaml-ESP32 and will be updated with my progress. It also serve as my notepad and thought long-term storage so you might expect random stuff there too!</summary></entry><entry><title type="html">Mirage on embedded devices: where are we?</title><link href="//home/lucas/TheLortex.github.io/esp32/mirage/native-backend/esp32/2018/03/20/mirage-and-esp32.html" rel="alternate" type="text/html" title="Mirage on embedded devices: where are we?" /><published>2018-03-20T12:13:37+00:00</published><updated>2018-03-20T12:13:37+00:00</updated><id>//home/lucas/TheLortex.github.io/esp32/mirage/native-backend/esp32/2018/03/20/mirage-and-esp32</id><content type="html" xml:base="//home/lucas/TheLortex.github.io/esp32/mirage/native-backend/esp32/2018/03/20/mirage-and-esp32.html">&lt;h2 id=&quot;a-bit-of-a-recap&quot;&gt;A bit of a recap&lt;/h2&gt;

&lt;p&gt;As an intern at the &lt;a href=&quot;https://ocamllabs.io/&quot;&gt;OCamlLab&lt;/a&gt;, my project is to port &lt;a href=&quot;https://mirage.io/&quot;&gt;MirageOS&lt;/a&gt; on a &lt;a href=&quot;https://www.espressif.com/en/products/hardware/esp32/overview&quot;&gt;ESP32 boards&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This will be done by two main projects:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Set up a cross-compilation toolchain from Mirage libraries to ESP32 target. It will be mainly for bytecode generation along with C stubs built with the xtensa gcc toolchain.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Add a new target to the OCaml compiler to have native code generation for xtensa processors.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-is-esp32&quot;&gt;What is ESP32&lt;/h3&gt;

&lt;p&gt;ESP32 is a series of chip microcontrollers which embeds Wifi and Bluetooth controllers. It integrates the following hardware:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Dual core Xtensa LX6 processors - 240Mhz&lt;/li&gt;
  &lt;li&gt;Ultra-low power coprocessor&lt;/li&gt;
  &lt;li&gt;520kb of RAM&lt;/li&gt;
  &lt;li&gt;4Mb of read-only flash&lt;/li&gt;
  &lt;li&gt;Wifi b/g/n transceiver&lt;/li&gt;
  &lt;li&gt;Bluetooth 4.2 Low Energy&lt;/li&gt;
  &lt;li&gt;Multiple peripheral interfaces&lt;/li&gt;
  &lt;li&gt;5μA deep-sleep current&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The base price of such a chip is $5, which makes it fairly cheap. Here are some derivations of the ESP32:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://wiki.wemos.cc/products:lolin32:lolin32_lite&quot;&gt;Base chip + USB&lt;/a&gt; ($5)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.sparkfun.com/products/13907&quot;&gt;Base chip + USB + Battery powered&lt;/a&gt; ($20)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.electrodragon.com/product/esp32-wrover-v4-module-based-esp32/&quot;&gt;Base chip + 4Mb PSRAM&lt;/a&gt; ($4.40)&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.electrodragon.com/product/esp32-wrover-kit/&quot;&gt;Base chip + USB  + 4Mb PSRAM + LCD screen + JTAG over USB + SD card support&lt;/a&gt; ($37.10)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hence this chip is very interesting for IoT projects, as it is versatile, low-power, and connected.&lt;/p&gt;

&lt;h4 id=&quot;programming-on-esp32&quot;&gt;Programming on ESP32&lt;/h4&gt;

&lt;p&gt;Espressif published a development guide and toolchain for C programming. You can find it as the &lt;a href=&quot;http://esp-idf.readthedocs.io/en/latest/&quot;&gt;ESP-IDF&lt;/a&gt; (IoT Development Framework) and there are all the resources needed to develop on this board. It contains a lot of documented libraries that help exploiting the features of ESP32 chips. It’s fairly easy to compile a simple program as the framework will automatically compile and link the code with ESP libraries and newlib, creating a flashable binary.&lt;/p&gt;

&lt;p&gt;This chip can also programmed trough:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://micropython.org/download#esp32&quot;&gt;MicroPython&lt;/a&gt; (Python for microcontrollers) features a Python toplevel on serial over USB. MicroPython libraries includes for example an easy way to connect to a Wifi hotspot and communicate with the world.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/espressif/arduino-esp32&quot;&gt;Arduino&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;what-is-mirage-&quot;&gt;What is Mirage ?&lt;/h3&gt;

&lt;p&gt;“MirageOS is a library operating system that constructs unikernels for secure, high-performance network applications across a variety of cloud computing and mobile platforms”. Written in OCaml, Mirage relies on opam package manager to download and build libraries.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;mirage&lt;/code&gt; package contains the OCaml tool which will build an unikernel from sources to a specific target. &lt;code class=&quot;highlighter-rouge&quot;&gt;mirage configure -t xen&lt;/code&gt; would for example create the list of packages needed to compile an unikernel for a Xen hypervisor.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The mirage library is composed of a lot of features libraries, sometimes target-specific, whose types implement one of the &lt;code class=&quot;highlighter-rouge&quot;&gt;mirage-types&lt;/code&gt;. These types defines interfaces for:&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Block devices&lt;/li&gt;
      &lt;li&gt;Channels&lt;/li&gt;
      &lt;li&gt;Time&lt;/li&gt;
      &lt;li&gt;Console&lt;/li&gt;
      &lt;li&gt;Filesystem&lt;/li&gt;
      &lt;li&gt;Network&lt;/li&gt;
      &lt;li&gt;…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;why-mirage-should-be-ported-to-the-esp32&quot;&gt;Why Mirage should be ported to the ESP32&lt;/h3&gt;

&lt;p&gt;Mirage is a library that allows the user to build applications without relying on a particular operating system, compiling it with minimal amount of libraries needed to run the application on bare metal or on top of an hypervisor. Thus a MirageOS unikernel can rely on operating system features such as network or devices without shipping millions of useless lines of code a typical OS can have.&lt;/p&gt;

&lt;p&gt;This improves security, performances and reduces the memory footprint of an application. That’s why having Mirage unikernels running on ESP32 boards is a great goal.&lt;/p&gt;

&lt;h2 id=&quot;where-are-we-now-&quot;&gt;Where are we now ?&lt;/h2&gt;

&lt;p&gt;We want to be able to ship OCaml code on ESP32 boards. However, Xtensa processors use a &lt;a href=&quot;https://0x04.net/~mwk/doc/xtensa.pdf&quot;&gt;specific&lt;/a&gt; instruction set. This instruction set is currently not supported by the OCaml compiler, the only compiler toolchain building for ESP32 being the &lt;a href=&quot;https://dl.espressif.com/dl/xtensa-esp32-elf-linux64-1.22.0-61-gab8375a-5.2.0.tar.gz&quot;&gt;xtensa-esp32-elf&lt;/a&gt; toolchain whose code hasn’t been distributed.&lt;/p&gt;

&lt;h3 id=&quot;bytecode-execution-on-the-esp32&quot;&gt;Bytecode execution on the ESP32&lt;/h3&gt;

&lt;p&gt;Hopefully, OCaml runtimes are written in C and can be built with the cross toolchain. With some efforts tweaking constants and Newlib compilation settings, Sadiq successfully compiled an OCaml code into bytecode which could be executed on an ESP32 board: &lt;a href=&quot;https://toao.com/blog/getting-ocaml-running-on-the-esp32&quot;&gt;Getting OCaml running on the ESP32&lt;/a&gt;. This is promising as it means we could build, link and run any OCaml library on an ESP32 target.&lt;/p&gt;

&lt;p&gt;However two problems were encountered:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;OCaml’s &lt;code class=&quot;highlighter-rouge&quot;&gt;Printf.printf&lt;/code&gt; doesn’t work out of the box. I figured out that ESP-IDF’s VFS is a bit broken and doesn’t correctly implement file descriptors behavior. I’ll write on article on that matter.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Using several libraries such as &lt;code class=&quot;highlighter-rouge&quot;&gt;Map&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;Pervasives&lt;/code&gt;, the size of the generated bytecode becomes too big for the 520kb RAM to hold. No problem! Let’s put it in flash, I just have to change a &lt;code class=&quot;highlighter-rouge&quot;&gt;static&lt;/code&gt; to a &lt;code class=&quot;highlighter-rouge&quot;&gt;static const&lt;/code&gt; in the C file containing the bytecode. Well it doesn’t work out of the box as the bytecode runtime actually perform an update pass over the bytecode to prepare it for threaded mode, therefore if the bytecode is set in flash memory it can’t be updated and an exception is raised. That pass had to be disabled in order to fix the issue. After that I could build more complex programs, generate their bytecode and run it on an ESP32 board.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cross-compilation-of-mirage-libraries&quot;&gt;Cross-compilation of mirage libraries&lt;/h3&gt;

&lt;h4 id=&quot;mirage-esp32-target&quot;&gt;Mirage ESP32 target&lt;/h4&gt;

&lt;p&gt;The first step towards compiling an unikernel with Mirage is to add a new target on the mirage configuration tool. Adding an esp32 target allows &lt;code class=&quot;highlighter-rouge&quot;&gt;mirage configure -t esp32&lt;/code&gt; to generate an unikernel package which will depend on ESP32 libraries implementations.&lt;/p&gt;

&lt;h4 id=&quot;opam-cross-esp32-libraries&quot;&gt;opam-cross-esp32 libraries&lt;/h4&gt;

&lt;p&gt;Mirage libraries required to build an unikernel come in a great number. Opam handles everything in case of host compilation, but there isn’t yet any way to cross-compile a package with its dependencies out of the box.&lt;/p&gt;

&lt;p&gt;As I looked online I figured out the best way to cross-compile stuff on OCaml is to do as &lt;code class=&quot;highlighter-rouge&quot;&gt;whitequark&lt;/code&gt; did with &lt;code class=&quot;highlighter-rouge&quot;&gt;opam-cross-android&lt;/code&gt;. The idea is to create for every package &amp;lt;&lt;em&gt;name&lt;/em&gt;&amp;gt;, a clone package &amp;lt;&lt;em&gt;name-esp32&lt;/em&gt;&amp;gt; which is cross-compiled with an &lt;code class=&quot;highlighter-rouge&quot;&gt;ocaml-esp32&lt;/code&gt; cross-toolchain and installed within a specific prefix.&lt;/p&gt;

&lt;p&gt;This is tedious work, and it can hardly be automated as there are a lot of patterns and use of different build systems. Generation of bytecode libraries along with C libraries is not such a problem, but it’s a bit ugly as some of these libraries rely on preprocessing libraries and tools that need to be built with a host toolchain. 
For example a build that rely on an ocamlbuild plugin need to have the plugin built with the host toolchain, before switching to the target toolchain in order to build the library.&lt;/p&gt;

&lt;p&gt;Right now every dependency of the noop mirage sample has its &lt;code class=&quot;highlighter-rouge&quot;&gt;-esp32&lt;/code&gt; version in &lt;a href=&quot;https://www.github.com/TheLortex/opam-cross-esp32&quot;&gt;opam-cross-esp32&lt;/a&gt;. However it has been done in a funky/hacky way and it doesn’t build out of the box.&lt;/p&gt;

&lt;h3 id=&quot;native-xtensa-backend-for-the-ocaml-compiler&quot;&gt;Native xtensa backend for the OCaml compiler&lt;/h3&gt;

&lt;p&gt;To reduce memory footprint and speed up execution, the end goal is to have a native backend of the OCaml compiler for ESP32 targets. This implies digging in the compiler source code as the documentation is fairly.. &lt;a href=&quot;https://github.com/ocamllabs/ocaml-internals/wiki&quot;&gt;empty&lt;/a&gt;. The work consists in writing the last layer of compilation which generates assembly code from the last intermediary language of OCaml compilation. It’s not that hard as I can read the source of several other backends for common architectures (ARM, i386, ..) and translate from there using the Xtensa Instruction Set Architecture.&lt;/p&gt;</content><author><name>Lucas Pluvinage</name></author><summary type="html">As an intern at the OCamlLab, my project is to port MirageOS on ESP32 boards. This is my first post to explain a bit what is the subject, give some links, hints on what is to be done.</summary></entry></feed>