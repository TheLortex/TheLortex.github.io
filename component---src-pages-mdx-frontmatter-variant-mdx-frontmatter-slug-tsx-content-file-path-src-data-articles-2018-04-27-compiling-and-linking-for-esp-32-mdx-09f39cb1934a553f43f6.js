"use strict";(self.webpackChunklucas_pluvinage=self.webpackChunklucas_pluvinage||[]).push([[900],{6930:function(e,t,l){l.r(t),l.d(t,{Head:function(){return p},default:function(){return m}});var n=l(7294),a=l(1151);function o(e){const t=Object.assign({p:"p",h2:"h2",code:"code",pre:"pre",ul:"ul",li:"li",a:"a"},(0,a.ah)(),e.components);return n.createElement(n.Fragment,null,n.createElement(t.p,null,"I've got native OCaml code running! It seems to pass all the runtime tests, and as I fixed some GC segfaults I'm now pretty confident in the backend code.\nIt's not optimized at all, but you can now experiment with OCaml on ESP32 MCUs."),"\n",n.createElement(t.h2,null,"OCaml cross-compiler installation"),"\n",n.createElement(t.p,null,"Switch opam to OCaml version 4.06 or a 4.07 as only these two versions are supported, using the ",n.createElement(t.code,null,"opam switch")," command."),"\n",n.createElement(t.p,null,"Add my cross-compilation repository in opam, with:"),"\n",n.createElement(t.pre,null,n.createElement(t.code,null,"opam repo add cross-esp32 https://github.com/TheLortex/opam-cross-esp32.git\n")),"\n",n.createElement(t.p,null,"After that, you'll be able to install the cross-compiler, with:"),"\n",n.createElement(t.pre,null,n.createElement(t.code,null,"opam install ocaml-esp32\n")),"\n",n.createElement(t.p,null,"You now have an OCaml cross-compiler for esp32 installed in ",n.createElement(t.code,null,"~/.opam/<switch>/esp32-sysroot/"),"."),"\n",n.createElement(t.h2,null,"Cross-compiling OCaml libraries"),"\n",n.createElement(t.p,null,"Your favorite build system can already cross-compile code. You can either use"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,n.createElement(t.code,null,"jbuilder build -x esp32 ...")),"\n",n.createElement(t.li,null,n.createElement(t.code,null,"ocamlfind -toolchain esp32 ...")),"\n",n.createElement(t.li,null,n.createElement(t.code,null,"env OCAMLFIND_TOOLCHAIN=esp32 ocamlbuild ..."),"\nto build libraries."),"\n"),"\n",n.createElement(t.p,null,"The libraries used by these build systems are located in ",n.createElement(t.code,null,"~/.opam/<switch>/esp32-sysroot/lib/"),". A good thing to know is that jbuilder automatically makes the difference between host code and target code, hence enabling the use of ppx tools."),"\n",n.createElement(t.h2,null,"Building an ESP32 application"),"\n",n.createElement(t.p,null,"To build an esp32 application, you'll need to link native code with the ESP-Iot Development Framework which contains libraries, bootloader code and linker scripts."),"\n",n.createElement(t.p,null,n.createElement(t.a,{href:"https://github.com/TheLortex/hello_caml"},"Hello caml")," is an example of project structure using jbuilder that builds a flashable binary for esp32."),"\n",n.createElement(t.p,null,"Basically, it's not complicated:"),"\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,"Build and ship OCaml code into a single object:","\n",n.createElement(t.ul,null,"\n",n.createElement(t.li,null,"using the ",n.createElement(t.code,null,"-output-complete-obj")," option on the native compiler ",n.createElement(t.code,null,"ocamlopt"),"."),"\n",n.createElement(t.li,null,"using ",n.createElement(t.code,null,"jbuilder build -x esp32 _build/default.esp32/main.exe.o")," that will automatically use the option."),"\n"),"\n"),"\n",n.createElement(t.li,null,"This object file's entry point is ",n.createElement(t.code,null,"caml_main"),". So the next thing to do is create a ",n.createElement(t.code,null,"startup-c.c")," file that defines a function ",n.createElement(t.code,null,"app_main")," which calls ",n.createElement(t.code,null,"caml_main"),"."),"\n",n.createElement(t.li,null,"Then everything needs to be linked together, and the ESP32 framework takes the lead to create the final binary."),"\n"))}var i=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?n.createElement(t,e,n.createElement(o,e)):o(e)},r=l(8733),c=l(4781),u=l(7166),s=l(4321);const d=e=>{var t,l,n,a,o,i,s,d,m,p;const h=null===(t=e.data.mdx)||void 0===t||null===(l=t.frontmatter)||void 0===l?void 0:l.tags,E=null!==(n=null==h?void 0:h.length)&&void 0!==n&&n&&null!==(a=u.tagsColor[h[0]])&&void 0!==a?a:u.tagsColor.default;return(0,r.tZ)(c.A,{page:null===(o=e.data.mdx)||void 0===o||null===(i=o.frontmatter)||void 0===i?void 0:i.variant,article:null===(s=e.data.mdx)||void 0===s||null===(d=s.frontmatter)||void 0===d?void 0:d.title},(0,r.tZ)("div",{sx:{padding:[0,1,3]}},(0,r.tZ)("div",{sx:{fontStyle:"italic",fontSize:1,padding:[1,0,0]}},null===(m=e.data.mdx)||void 0===m||null===(p=m.frontmatter)||void 0===p?void 0:p.date),(0,r.tZ)("div",{sx:{borderLeft:"solid "+E+" 8px",paddingX:[2,4]}},e.children)))};function m(e){return n.createElement(d,e,n.createElement(i,e))}const p=e=>{var t,l,n;return(0,r.tZ)(s.x,{title:null!==(t=null===(l=e.data.mdx)||void 0===l||null===(n=l.frontmatter)||void 0===n?void 0:n.title)&&void 0!==t?t:void 0})}}}]);
//# sourceMappingURL=component---src-pages-mdx-frontmatter-variant-mdx-frontmatter-slug-tsx-content-file-path-src-data-articles-2018-04-27-compiling-and-linking-for-esp-32-mdx-09f39cb1934a553f43f6.js.map