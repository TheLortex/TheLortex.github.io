"use strict";(self.webpackChunklucas_pluvinage=self.webpackChunklucas_pluvinage||[]).push([[365],{9686:function(e,t,n){n.r(t),n.d(t,{Head:function(){return p},default:function(){return h}});var a=n(7294),l=n(1151),i=n.p+"static/obj_magic-2d96f4d86cc70e5d70af0612885a2620.jpg";function s(e){const t=Object.assign({p:"p",a:"a",h2:"h2",pre:"pre",code:"code",ul:"ul",li:"li",em:"em",span:"span",strong:"strong",h3:"h3"},(0,l.ah)(),e.components);return a.createElement(a.Fragment,null,a.createElement(t.p,null,"CPUs are very good at doing things in parallel, even in a single core context.\nIndeed, speculative execution of code and instruction reordering helps the CPU\nensure that the pipeline is always full. However, data dependencies in the\nsequence of instructions might cause the CPU to have to wait for data, be it\nfrom the L1 cache or the much slower RAM storage. Francesco Mazzoli shows in their blog post, ",a.createElement(t.a,{href:"https://mazzo.li/posts/value-speculation.html"},"Beating the L1 cache with value speculation")," ,\nthat optimizing the critical path will in some conditions yield huge performance\nimprovements."),"\n",a.createElement(t.p,null,"This article demonstrates that this optimisation can be implemented in the\nOCaml programming language. Knowing how OCaml values are represented in memory is useful, here is a chapter of Real World OCaml on that matter: ",a.createElement(t.a,{href:"https://dev.realworldocaml.org/runtime-memory-layout.html"},"Memory Representation of Values"),"."),"\n",a.createElement(t.h2,null,"Fast list iterations using one simple trick™"),"\n",a.createElement(t.p,null,"Let's start by instantiating a linked list of 10000 random numbers."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-ocaml"},"let l = List.init 10000 (fun _ -> Random.int 1024)\n")),"\n",a.createElement(t.p,null,"Now, let's sum the numbers 100k times and see how long that takes. To obtain these statistics, ",a.createElement(t.code,null,"perf stat")," was used with the default settings on programs compiled with OCaml 5.0."),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-ocaml"},"let rec sum (accumulator: int) (cell: int list) =\n  match cell with\n  | head::tail -> sum (accumulator + head) tail\n  | [] -> accumulator\n\nfor _ = 1 to 100000 do\n  ignore (sum 0 l)\ndone\n")),"\n",a.createElement(t.pre,null,a.createElement(t.code,null," Performance counter stats for './a.out sum':\n\n          1 368,91 msec task-clock:u                     #    0,999 CPUs utilized\n     4 835 597 233      cycles:u                         #    3,532 GHz\n     9 005 641 989      instructions:u                   #    1,86  insn per cycle\n     3 001 229 709      branches:u                       #    2,192 G/sec\n           195 819      branch-misses:u                  #    0,01% of all branches\n")),"\n",a.createElement(t.p,null,"Conveniently, we're doing one billion additions (10000 list items, repeated 100k times). So each iteration is taking:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"1.36 nanoseconds"),"\n",a.createElement(t.li,null,"4.8 cycles"),"\n",a.createElement(t.li,null,"9 instructions"),"\n",a.createElement(t.li,null,"3 branches"),"\n"),"\n",a.createElement(t.p,null,"We can already see that the CPU is cramming multiple instructions per cycle.\nUsing the ",a.createElement(t.a,{href:"https://godbolt.org/"},"compiler explorer"),", the following assembly is obtained:"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-nasm"},"camlExample__sum_268:\n        subq    $8, %rsp\n.L101:\n        cmpq    (%r14), %r15         # check if GC is waiting for us\n        jbe     .L102                # branch #1\n.L103:\n        testb   $1, %bl              # check if at end of list\n        je      .L100                # branch #2\n        addq    $8, %rsp\n        ret\n.L100:\n        movq    8(%rbx), %rdi        # load tail element of list\n        movq    (%rbx), %rbx         # load head element of list\n        leaq    -1(%rbx,%rax), %rax  # add it to accumulator\n        movq    %rdi, %rbx           # move tail element for next iteration\n        jmp     .L101\n.L102:\n        call    caml_call_gc@PLT\n.L104:\n        jmp     .L103\n")),"\n",a.createElement(t.p,null,"I've tried to think like a CPU in order to explain the numbers according to the perf results, but as so many pieces are involved I assumed it would be hard for everything to be correct. Instead, we'll try to get a good ",a.createElement(t.em,null,"intuition")," by thinking in terms of ",a.createElement(t.em,null,"data dependency"),". Basically, the assumption is that things that do not depend on each other can be ran in parallel. The second assumption is that thanks to the ",a.createElement(t.em,null,"branch predictor"),", branch instructions are supposed to have zero cost and they don't introduce data dependencies. Instead, the CPU predicts whether the program will go through the branch and continue execution. In case of misprediction, the CPU will roll back computations for us."),"\n",a.createElement(t.p,null,"So here is the data dependency chart for this program, showing how two iterations are expected to be ran, with the critical path in red:"),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/0ee27ac4c33fd4dc2224c18363d91a17/d07ca/sum_chart.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 22.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAABQElEQVQY0xWQ20oCURSG9wP0Er1MF11EWhB1W+8SGV0UjDHdCqJiUXlKi6CcLDyk4OSMlofUOc+4Z/boaAOy2l6txcf/869/Ic00ARMydWZeUjHNmOk4cXexiLrzeVrB+BDEFvJVBQ0l6VS3LDAwfletSWSsaYkJITGLkIRh25E7MltzuFeEZL4JCt9Upo8PeyST2rYz90H9Jhmwbq8Di6fCzrLEHXXOQuvtN+5EF1pgVcrny1x6wy3kdnWqIdlUwMtng37xZd/L5w6Q2xZh3u+BQ+dvpQzDagV0GoJFAUhHBJPuo4/S8Ygrhv56XZh9d8ARvkCuVUH6rMHKv2KYhqmUIQPbYVoxTM9mxqrGyLrO0LqM5/uMbBgXdZ6PPhe5zWqjsUXfE5M17bI7GLA//T4rKSpLGUs9bFMQrsr1BvsP2f8CVHGId2YAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="data chart"\n        title=""\n        src="/static/0ee27ac4c33fd4dc2224c18363d91a17/c1b63/sum_chart.png"\n        srcset="/static/0ee27ac4c33fd4dc2224c18363d91a17/5a46d/sum_chart.png 300w,\n/static/0ee27ac4c33fd4dc2224c18363d91a17/0a47e/sum_chart.png 600w,\n/static/0ee27ac4c33fd4dc2224c18363d91a17/c1b63/sum_chart.png 1200w,\n/static/0ee27ac4c33fd4dc2224c18363d91a17/d61c2/sum_chart.png 1800w,\n/static/0ee27ac4c33fd4dc2224c18363d91a17/97a96/sum_chart.png 2400w,\n/static/0ee27ac4c33fd4dc2224c18363d91a17/d07ca/sum_chart.png 2523w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",a.createElement(t.p,null,"Even if the tail pointer is loaded from cache, we still have to pay a 4 cycles cost to fetch from the L1 cache."),"\n",a.createElement(t.p,null,"The ",a.createElement(t.strong,null,"Check GC")," part of the loop is independent from the rest, and is useful in a multicore context as every domain of the program has to synchronize when performing garbage collection."),"\n",a.createElement(t.h2,null,"Value speculation"),"\n",a.createElement(t.p,null,"It's time to open the rune book and perform some dark magic. We know that we\nwon't get past that 4 cycles per iteration bottleneck unless there is a way to\nbypass the pointer chasing. To do that, we're going to do what was done in\nthe value speculation article, but in pure OCaml."),"\n","\n",a.createElement(t.p,null,"The principle is the same: ",a.createElement(t.code,null,"cell"),' is converted to a "pointer" using the forbidden ',a.createElement("a",{href:i},a.createElement(t.code,null,"Obj.magic"))," function. Using the value of the ",a.createElement(t.code,null,"previous")," list\ncell pointer, we can compute ",a.createElement(t.code,null,"delta"),", the number of bytes between the two last cells.\nThis is used to estimate where will be the next cell. If the prediction is correct,\nthe memory load of the next cell address is effectively bypassed, and the CPU can\ndirectly start working on the next iteration. If not, the branch predictor rolls back the\ncomputation."," "),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1093px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/b6a2941fbaf286b58431c35c774b74a5/d3f96/seum_delta_1.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 30.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsSAAALEgHS3X78AAABKElEQVQY03VQa2+DMAzk//+xfdi0rVSqtLLwCGlLgPAmlLTJzaSapk2aJSvW3Tn2Oei6DmVZQimFq55gVw2zTHBGY54GNE3jc55Gz63LQ7PMI9q2RV3XGMcRWzjnEAghcDgcEMcJ2iLDJBkaEUGXMZQU4DwHz3OqT5glYeLoNa3kyKk3iiK/zHcEy7KgJqAfBg9Y9yC2ZzXGi7e83y0sfjhzu+HhroIhne+1FoFeVjx9FAijHOHuzVuIYwYpJRRZfT6e8RpdsA9DFMUFaZpiczX0Hd4/z3hhFXbhHowxDLRUcF0N2KUHL2rwLEPf9/6mLX3cNS1YJpGKiuzl/mYV4aqqMFKd8AKJUOA04Hw6QWuNAP+EI0uOhuFmtmv/IR3sdSXfxNn7L+oL4GHIakLWJrEAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="illustration of the delta computing mechanism "\n        title=""\n        src="/static/b6a2941fbaf286b58431c35c774b74a5/d3f96/seum_delta_1.png"\n        srcset="/static/b6a2941fbaf286b58431c35c774b74a5/5a46d/seum_delta_1.png 300w,\n/static/b6a2941fbaf286b58431c35c774b74a5/0a47e/seum_delta_1.png 600w,\n/static/b6a2941fbaf286b58431c35c774b74a5/d3f96/seum_delta_1.png 1093w"\n        sizes="(max-width: 1093px) 100vw, 1093px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-ocaml"},"let rec sum (previous : int) (accu : int) (cell : int list) =\n  match cell with\n  | [] -> accu\n  | head::tail ->\n    let current : int = Obj.magic cell in\n    let prediction : int list =\n      Obj.magic (2 * current - previous)\n    in\n    sum\n      current\n      (accu + head)\n      (if prediction == tail then prediction else tail)\n")),"\n",a.createElement(t.pre,null,a.createElement(t.code,null," Performance counter stats for './a.out seum':\n\n            944,67 msec task-clock:u                     #    1,000 CPUs utilized\n     3 422 107 884      cycles:u                         #    3,623 GHz\n    16 006 647 403      instructions:u                   #    4,68  insn per cycle\n     5 001 230 197      branches:u                       #    5,294 G/sec\n           225 781      branch-misses:u                  #    0,00% of all branches\n")),"\n",a.createElement(t.p,null,"Per iteration:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"0.94 nanoseconds"),"\n",a.createElement(t.li,null,"3.4 cycles"),"\n",a.createElement(t.li,null,"16 instructions"),"\n",a.createElement(t.li,null,"5 branches"),"\n"),"\n",a.createElement(t.p,null,"We got past the bottleneck ! What we're effectively doing is transforming the list iteration into an array iteration. And this works, because there are situations where OCaml lists are allocated in a linear fashion, making the cell addresses predictible. Note in particular the huge number of instructions per cycle."),"\n",a.createElement(t.p,null,"If you are not convinced, here is an updated dependency diagram for this program."),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/0e7c68e5183233304bf79def6aa2b5e5/37d90/seum_chart.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 20%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsSAAALEgHS3X78AAABOElEQVQY0w2Qy0rDQBiF58EKgq/iwpXoQqSpigsRfQe7ceXChS1YBRUrIoitl6S5NG2szWUySSYzuTWxRai/szibw+GD76A4jiHPcyemtB0Q0inLslUUxQPG3kqSpKjff0dBGCFCyCkTW5GO53lXjLF2lmW3lNKjqqqQbdtIURSEIhpDmhfPlKdrLiYbjuvVgyCUillZF8AdYzg87HafaubYasaMAWV8y/WDdbHb9ly3ITqJcy4JoCTLsoTmof43j0yoAgNmvgZJND1Ok2h38ZMdVAXfn1jGSe/lfjU0H5sFViH3VEjsD0j90XUQ8c08y/aEYUMYSJqmSShyDGB4vMRfg6Uz+ly4zvcNIX5LHSidXu/1HABQWf4i23w7474FoW3MsSUDno5kccWF6ziXQvVOVdWaruvoHxUNBL4fzwdXAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="seum chart"\n        title=""\n        src="/static/0e7c68e5183233304bf79def6aa2b5e5/c1b63/seum_chart.png"\n        srcset="/static/0e7c68e5183233304bf79def6aa2b5e5/5a46d/seum_chart.png 300w,\n/static/0e7c68e5183233304bf79def6aa2b5e5/0a47e/seum_chart.png 600w,\n/static/0e7c68e5183233304bf79def6aa2b5e5/c1b63/seum_chart.png 1200w,\n/static/0e7c68e5183233304bf79def6aa2b5e5/d61c2/seum_chart.png 1800w,\n/static/0e7c68e5183233304bf79def6aa2b5e5/97a96/seum_chart.png 2400w,\n/static/0e7c68e5183233304bf79def6aa2b5e5/37d90/seum_chart.png 3003w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",a.createElement(t.p,null,"By moving the tail pointer load outside of the critical path, the CPU is able to do more things at once. The following chart shows how one can expect the CPU to execute instructions for three iterations in parallel."),"\n",a.createElement(t.span,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/static/33d0488feef08b4620b60d3776e40b59/344cf/seum_chart_tiled.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsSAAALEgHS3X78AAACZElEQVQozx2SyU8TcRiGPxb/Af0TSLx4JvFmYry4JCbejVeUA8ZAuJhIvEokJIZYXIIQClgDtAWqtHShlOlCO9DS0mmZrkNnaaczna4ylM9f/ZLn+rzvm3xQLpexVqv1OOU4jlYUhW+329hoNLBUKr2PJ5L3vJGEcEAn0RmMXa3Z9un1PX/Euh8Jm91HjGmXemqyU0AYgN6l0+mfDMO863a7kMvlQBCE0V4IEftEUVwqFovrqUyhcZ7jUJblOUTsJ/RlE5F+GKWAOj6DhY3d/66hB88BVFUda7dbrzVNmySCVwQzaYqSJM1d6fqTRrP54rebUi0Ob46IoNPpQKuhQeY8BWKBBTqZueGLsgM2T3Bwbds5CCTVQOYZiPgLy7IzPM/HqtUq1jUNSUivKVbKIkoiL7fqtbd6pzVZrUgTaeZsisswd0KxFLjpFFicFCxb7ACXtQr8rVVBrysg8xzkBXlIqWkTqlZ/WbwojSTT7Jg/miqH4ixGklkkE9EXPkWPP4IOik6YPeEZi+fo65LZYfhstBhAiW8ZxWOrsRq3LavJ3ZUWszMvBI3TfHD1oxrdmNbi1tlEaE+l/S48Cbg60YALQ5TTPb/pfmay+0e2D+jxbd/JG+OWa9ywap2AlpzHS43HupTFSpFBTWRR1wTU6wIqpTRK+QSexmgMR8LXwaC/e+jzosvrZbe89I8d3/EiES3Mr5i/L//x3/z2ywZQkJrDchOH86J2N5ws3eb48mxV1ZDQKRQv9EyuqDNZ7vq8IOAZW7gK0DE8DMfsJkfgPnmbx6s276PFTfvDRYvr1tSHT33/APMi5m4eaZULAAAAAElFTkSuQmCC\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="seum chart tiled"\n        title=""\n        src="/static/33d0488feef08b4620b60d3776e40b59/c1b63/seum_chart_tiled.png"\n        srcset="/static/33d0488feef08b4620b60d3776e40b59/5a46d/seum_chart_tiled.png 300w,\n/static/33d0488feef08b4620b60d3776e40b59/0a47e/seum_chart_tiled.png 600w,\n/static/33d0488feef08b4620b60d3776e40b59/c1b63/seum_chart_tiled.png 1200w,\n/static/33d0488feef08b4620b60d3776e40b59/d61c2/seum_chart_tiled.png 1800w,\n/static/33d0488feef08b4620b60d3776e40b59/97a96/seum_chart_tiled.png 2400w,\n/static/33d0488feef08b4620b60d3776e40b59/344cf/seum_chart_tiled.png 2643w"\n        sizes="(max-width: 1200px) 100vw, 1200px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",a.createElement(t.h3,null,"Optimized"),"\n",a.createElement(t.p,null,"I was not satisfied by this mere 45% improvement. What if the loop was unrolled, so that the CPU has more freedom to move instructions around ?"),"\n",a.createElement(t.pre,null,a.createElement(t.code,{className:"language-ocaml"},"let rec seum_unroll (previous : int) (accu : int) (cell : int list) =\n  match cell with\n  | [] -> accu\n  | [a] ->  accu + a\n  | [a; b] -> accu + a + b\n  | [a; b; c] -> accu + a + b + c\n  | a::b::c::d::tail ->\n      let current = Obj.magic cell in\n      let prediction : int list =\n        Obj.magic (2 * current - previous)\n      in\n      seum_unroll\n        current\n        (accu + a + b + c + d)\n        (if prediction == tail then prediction else tail)\n")),"\n",a.createElement(t.p,null,"The idea is to iterate on the list by chunks of 4 items. There is still the same amount of work to do, but the value prediction trick is performed once every 4 element."),"\n",a.createElement(t.pre,null,a.createElement(t.code,null," Performance counter stats for './a.out seum_unroll':\n\n            715,58 msec task-clock:u                     #    0,999 CPUs utilized\n     2 410 830 333      cycles:u                         #    3,369 GHz\n     7 756 543 257      instructions:u                   #    3,22  insn per cycle\n     2 001 229 820      branches:u                       #    2,797 G/sec\n           112 956      branch-misses:u                  #    0,01% of all branches\n")),"\n",a.createElement(t.p,null,"Per iteration:"),"\n",a.createElement(t.ul,null,"\n",a.createElement(t.li,null,"0.72 nanoseconds"),"\n",a.createElement(t.li,null,"2.4 cycles"),"\n",a.createElement(t.li,null,"7.7 instructions"),"\n",a.createElement(t.li,null,"2 branches"),"\n"),"\n",a.createElement("h1",{style:{fontSize:"4em",marginTop:"-50px",marginBottom:"-50px"}},a.createElement(t.p,null,a.createElement("b",null,"91.3%")," faster. Nice.")),"\n",a.createElement(t.p,null,"According the original article, we're now faster than the naive C implementation, but 2x slower than the hand-optimized one. This is all very synthetic but I found it quite interesting that OCaml is able to benefit from the same hacks as C. Of course this won't be useful in a lot of situations, but maybe one will gain some insights on how modern CPU are able to make programs go fast."))}var c=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,l.ah)(),e.components);return t?a.createElement(t,e,a.createElement(s,e)):s(e)},r=n(8733),o=n(6405),m=n(7166),d=n(4321);const u=e=>{var t,n,a,l,i,s,c,d;const u=null===(t=e.data.mdx)||void 0===t||null===(n=t.frontmatter)||void 0===n?void 0:n.tags,h=null!==(a=null==u?void 0:u.length)&&void 0!==a&&a&&null!==(l=m.tagsColor[u[0]])&&void 0!==l?l:m.tagsColor.default;return(0,r.tZ)(o.A,{page:null===(i=e.data.mdx)||void 0===i||null===(s=i.frontmatter)||void 0===s?void 0:s.variant,article:null===(c=e.data.mdx)||void 0===c||null===(d=c.frontmatter)||void 0===d?void 0:d.title},(0,r.tZ)("div",{sx:{padding:[1,3]}},(0,r.tZ)("div",{sx:{borderLeft:"solid "+h+" 8px",paddingX:[2,4]}},e.children)))};function h(e){return a.createElement(u,e,a.createElement(c,e))}const p=e=>{var t,n,a;return(0,r.tZ)(d.x,{title:null!==(t=null===(n=e.data.mdx)||void 0===n||null===(a=n.frontmatter)||void 0===a?void 0:a.title)&&void 0!==t?t:void 0})}}}]);
//# sourceMappingURL=component---src-pages-mdx-frontmatter-variant-mdx-frontmatter-slug-tsx-content-file-path-src-data-articles-2023-05-05-value-speculation-ocaml-mdx-ea1d5d4fd4c119da0778.js.map